load("//:defs.bzl", "rust_bootstrap_binary", "rust_bootstrap_library")
load("//constraints:defs.bzl", "transition_alias")

rust_bootstrap_library(
    name = "hostcalls_lib",
    srcs = glob(
        ["src/**/*.rs"],
        exclude = ["src/main.rs"],
    ),
    crate = "hostcalls",
    crate_root = "src/lib.rs",
    edition = "2024",
    visibility = ["PUBLIC"],
    deps = ["//hostcall-demo/third-party:cust"],
)

rust_bootstrap_library(
    name = "libc_hostcall",
    srcs = [],  # placeholder; see nvptx-specific rule below
    crate = "libc_hostcall",
    crate_root = "libc-hostcall/src/lib.rs",
    edition = "2024",
    visibility = ["PUBLIC"],
)

# NVPTX build of libc_hostcall forcing the nvptx toolchain and platform.
native.rust_library(
    name = "libc_hostcall_nvptx",
    crate = "libc_hostcall",
    crate_root = "libc-hostcall/src/lib.rs",
    srcs = glob(["libc-hostcall/src/**/*.rs"]),
    edition = "2024",
    visibility = ["PUBLIC"],
    default_target_platform = "//platforms/nvptx:library",
    resources = ["//target_specs:nvptx64-vectorware-target-dir"],
    env = {"RUST_TARGET_PATH": "$(location //target_specs:nvptx64-vectorware-target-dir)"},
    deps = [
        "//:alloc",
        "//:core",
    ],
    _rust_toolchain = "toolchains//:rust_nvptx",
)

rust_bootstrap_library(
    name = "culinux_nvptx",
    srcs = glob(["culinux/src/**/*.rs"]),
    crate = "culinux",
    crate_root = "culinux/src/lib.rs",
    edition = "2024",
    preferred_linkage = "static",
    resources = [
        "//target_specs:nvptx64-vectorware-target-dir",
    ],
    rustc_flags = [
        "-Zunstable-options",
        "-Cpanic=abort",
    ],
    deps = [
        ":libc_hostcall_nvptx",
        "//:alloc",
    ],
    target_compatible_with = ["//constraints:target=nvptx64"],
    _rust_toolchain = "toolchains//:rust_nvptx_full",
)

transition_alias(
    name = "culinux_nvptx_alias",
    actual = ":culinux_nvptx",
    incoming_transition = "//platforms/nvptx:library",
    visibility = ["PUBLIC"],
)

rust_bootstrap_binary(
    name = "hostcalls_bin",
    crate = "hostcalls",
    crate_root = "src/main.rs",
    srcs = glob(["src/**/*.rs"]),
    edition = "2024",
    rustc_flags = ["-Clink-arg=-lcuda"],
    visibility = ["PUBLIC"],
    env = {},
    deps = [
        ":hostcalls_lib",
        "//hostcall-demo/third-party:cust",
        ":culinux_ptx_rs_lib",
    ],
)

native.genrule(
    name = "culinux_ptx_raw",
    srcs = [
        ":culinux_nvptx_alias[static_pic]",
        "//stage0:ci_llvm",
        "//stage1:std__nvptx[static]",
        "//stage1:alloc__nvptx[static]",
        "//stage1:core__nvptx[static]",
        "//stage1:compiler_builtins__nvptx[static]",
        "//stage1:panic_abort__nvptx[static]",
        ":libc_hostcall_nvptx[static]",
        # Ensure PTX rebuilds when the kernel source changes.
    ] + glob(["culinux/src/**/*.rs"]),
    default_target_platform = "//platforms/nvptx:library",
    target_compatible_with = ["//constraints:target=nvptx64"],
    out = "libculinux.ptx",
    cmd = "bash -c 'set -euo pipefail; TMP=/tmp/culinux-$$; rm -rf \"$TMP\"; mkdir -p \"$TMP\"; trap \"rm -rf $TMP\" EXIT; "
        + "SRCDIR=\"$PWD\"; OUT=\"$PWD/$OUT\"; LLVM_DIR=\"$PWD/ci-llvm\"; "
        + "LIBS=\"$SRCDIR/$(location :culinux_nvptx_alias[static_pic]) $SRCDIR/$(location //stage1:std__nvptx[static]) $SRCDIR/$(location //stage1:alloc__nvptx[static]) $SRCDIR/$(location //stage1:core__nvptx[static]) $SRCDIR/$(location //stage1:compiler_builtins__nvptx[static]) $SRCDIR/$(location //stage1:panic_abort__nvptx[static]) $SRCDIR/$(location :libc_hostcall_nvptx[static])\"; "
        + "cd \"$TMP\"; for R in $LIBS; do ar x \"$R\"; done; "
        + "OBJS=`ls *.o 2>/dev/null || true`; "
        + "if [ -z \"$OBJS\" ]; then echo \"no object files\" >&2; exit 1; fi; "
        + "\"$LLVM_DIR\"/bin/llvm-link $OBJS -o culinux.bc; "
        + "\"$LLVM_DIR\"/bin/opt -passes=internalize,globaldce -internalize-public-api-list=kernel_main culinux.bc -o culinux.opt.bc; "
        + "\"$LLVM_DIR\"/bin/opt -O2 culinux.opt.bc -o culinux.opt.bc; "
        + "\"$LLVM_DIR\"/bin/llc -mcpu=sm_89 culinux.opt.bc -o \"$OUT\"' ",
    visibility = ["PUBLIC"],
)

transition_alias(
    name = "culinux_ptx",
    actual = ":culinux_ptx_raw",
    incoming_transition = "//platforms/nvptx:library",
    visibility = ["PUBLIC"],
)

# Small Rust wrapper to embed the generated PTX directly into the host binary.
# Include the PTX hash so this target (and crates consuming it) rebuild when the PTX changes.
native.genrule(
    name = "culinux_ptx_rs_v2",
    srcs = [":culinux_ptx"],
    out = "culinux_ptx.rs",
    cmd = "PTX=$(location :culinux_ptx); "
        + "HASH=`sha256sum \"$PTX\" | cut -d\" \" -f1`; "
        + "cat > \"$OUT\" <<EOF\n"
        + "pub static PTX: &[u8] = include_bytes!(\"$PTX\");\n"
        + "pub const PTX_HASH: &str = \"$HASH\";\n"
        + "EOF",
    visibility = ["PUBLIC"],
)

rust_bootstrap_library(
    name = "culinux_ptx_rs_lib",
    srcs = [":culinux_ptx_rs_v2"],
    crate = "culinux_ptx_rs",
    crate_root = "culinux_ptx.rs",
    edition = "2024",
    visibility = ["PUBLIC"],
)
